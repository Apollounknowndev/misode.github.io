use ::java::data::gametest::Rotation
use ::java::data::worldgen::feature::placement::PlacedFeatureRef
use ::java::data::worldgen::feature::block_predicate::BlockPredicate
use ::java::data::worldgen::feature::block_state_provider::BlockStateProvider
use ::java::data::worldgen::template_pool::Element
use ::java::data::worldgen::processor_list::BlockEntityModifier
use ::java::data::worldgen::processor_list::PosRuleTest
use ::java::data::worldgen::processor_list::Processor
use ::java::data::worldgen::processor_list::ProcessorListRef
use ::java::data::worldgen::structure::SpawnOverride
use ::java::data::worldgen::structure::PoolAlias
use ::java::data::worldgen::structure::LiquidSettings
use ::java::data::worldgen::structure::TerrainAdaptation
use ::java::data::worldgen::surface_rule::SurfaceRule
use ::java::data::worldgen::surface_rule::SurfaceCondition
use ::java::data::worldgen::DecorationStep
use ::java::data::worldgen::IntProvider
use ::java::data::worldgen::FloatProvider
use ::java::data::worldgen::HeightmapType
use ::java::data::worldgen::HeightProvider
use super::WeightedList
use super::InclusiveRange
use super::SquareBaseBox
use super::PlacementCondition





// BLOCK PREDICATE






struct StatePredicate {
	[string]: string,
}

dispatch minecraft:block_predicate["lithostitched:block_state"] to struct BlockStatePredicate {
	properties?: StatePredicate,
}

dispatch minecraft:block_predicate["lithostitched:in_structure"] to struct InStructurePredicate {
	structure?: (#[id="worldgen/structure"] string),
	search_range: SquareBaseBox<int @ 0..32>
}

dispatch minecraft:block_predicate["lithostitched:multiple_of"] to struct MultipleOfPredicate {
	predicates: [BlockPredicate],
	allowed_count: InclusiveRange<int @ 0..>
}

dispatch minecraft:block_predicate["lithostitched:random_chance"] to struct RandomChancePredicate {
	chance: float @ 0..1
}





// BLOCK STATE PROVIDER





dispatch minecraft:block_state_provider["lithostitched:random_block"] to struct RandomBlockProvider {
	blocks: (#[id(registry="block",tags="required")] string | [#[id="block"] string])
}

dispatch minecraft:block_state_provider["lithostitched:weighted"] to struct WeightedProvider {
	entries: WeightedList<BlockStateProvider>
}





// PLACEMENT MODIFIERS





dispatch minecraft:placement_modifier["lithostitched:condition"] to struct ConditionPlacement {
	condition: PlacementCondition
}

dispatch minecraft:placement_modifier["lithostitched:noise_slope"] to struct NoiseSlopePlacement {
	noise: (#[id="worldgen/noise"] string),
	slope: int,
	offset?: int,
	xz_scale: double,
	y_scale: double
}

dispatch minecraft:placement_modifier["lithostitched:offset"] to struct OffsetPlacement {
	x_offset?: IntProvider<int @ -16..16>,
	y_offset?: IntProvider<int>,
	z_offset?: IntProvider<int @ -16..16>,
}





// CONFIGURED FEATURES





dispatch minecraft:feature_config["lithostitched:composite"] to struct CompositeConfig {
	features: (#[id(registry="worldgen/placed_feature",tags="required")] string | [#[id="worldgen/placed_feature"] string]),
	placement_type?: PlacementType
}

enum(string) PlacementType {
	NeverCancel = "never_cancel",
	CancelOnFailure = "cancel_on_failure",
	CancelOnSuccess = "cancel_on_success",
}

dispatch minecraft:feature_config["lithostitched:dungeon"] to struct DungeonConfig {
	/// The minimum number of openings in the walls of the dungeon. Defaults to 1.
	min_openings?: int @ 0..,
	/// The maximum number of openings in the walls of the dungeon. Defaults to 5.
	max_openings?: int @ 0..,
	/// The radius of the interior on each axis. Defaults to a uniform int provider between 2 and 3.
	radius?: IntProvider<int @ 1..16>,
	/// The maximum number of chest placements. Defaults to 2.
	max_chests?: int @ 0..,
	/// A weighted list of entities that can be in the spawner. Defaults to the vanilla spawner mob chances (50% zombie, 25% skeleton, 25% spider)
	spawner_entity?: WeightedList<#[id="entity_type"] string>,
	/// The block state provider for the floor of the dungeon. Defaults to the vanilla dungeon floor (75% mossy cobblestone, 25% cobblestone)
	floor_provider?: BlockStateProvider,
	/// The block state provider for the walls of the dungeon. Defaults to just cobblestone.
	wall_provider?: BlockStateProvider,
	/// The blocks that the dungeon cannot override. Defaults to #minecraft:features_cannot_replace.
	dungeon_invalid_blocks?: (#[id(registry="block",tags="allowed")] string | [#[id="block"] string]),
	/// The loot table for the chests to use. Defaults to minecraft:chests/simple_dungeon.
	loot_table?: #[id="loot_table"] string
}

dispatch minecraft:feature_config["lithostitched:large_dripstone"] to struct AltLargeDripstoneConfig {
	floor_to_ceiling_search_range?: int @ 1..512,
	column_radius: IntProvider<int @ 0..60>,
	height_scale: FloatProvider<float @ 0..20>,
	max_column_radius_to_cave_height_ratio: float @ 0..1,
	stalactite_bluntness: FloatProvider<float @ 0.1..10>,
	stalagmite_bluntness: FloatProvider<float @ 0.1..10>,
	wind_speed: FloatProvider<float @ 0..2>,
	min_radius_for_wind: int @ 0..100,
	min_bluntness_for_wind: float @ 0..1,
	/// The block state provider to use.
	state_provider: BlockStateProvider,
	/// The blocks that can be replaced by the blocks in the state_provider.
	replaceable_blocks: (#[id(registry="block",tags="allowed")] string | [#[id="block"] string])
}

dispatch minecraft:feature_config["lithostitched:ore"] to struct AltOreConfig {
	size: int @ 0..128,
	targets: [AltOreTarget]
}

struct AltOreTarget {
	predicate: BlockPredicate,
	state_provider: BlockStateProvider
}

dispatch minecraft:feature_config["lithostitched:select"] to struct SelectConfig {
	/// A list of block predicates and their corresponding placed features. The first entry in the list with the block predicate met will place its feature. 
	features: [SelectEntry]
}

struct SelectEntry {
	predicate: BlockPredicate,
	feature: PlacedFeatureRef
}

dispatch minecraft:feature_config["lithostitched:structure_template"] to struct StructureTemplateConfig {
	/// The structure template nbt to place.
	template: #[id="structure"] string,
	/// The processors to apply to the structure template.
	processors: ProcessorListRef,
	/// The rotation for the template to be placed relative to its rotation when saved. If left empty, a random rotation will be applied.
	rotation?: Rotation,
	/// Defaults to apply_waterlogging.
	liquid_settings?: LiquidSettings,
	/// If set, the jigsaw block in the structure with this name will be where the template is placed relative to.
	start_jigsaw_name?: #[id] string
}

dispatch minecraft:feature_config["lithostitched:vines"] to struct VinesConfig {
	/// All blocks here MUST be vine blocks! Defaults to the vanilla vine block.
	state?: (#[id="block"] string | WeightedList<#[id="block"] string>),
	/// The blocks the vines can start growing from. If empty, any blocks are allowed.
	can_place_on?: (#[id(registry="block",tags="required")] string | [#[id="block"] string]),
	/// The length the vines will grow. Defaults to a constant of one.
	max_length?: IntProvider<int @ 1..256>
}

dispatch minecraft:feature_config["lithostitched:weighted_selector"] to struct WeightedSelectorConfig {
	features: WeightedList<PlacedFeatureRef>
}

dispatch minecraft:feature_config["lithostitched:well"] to struct WellConfig {
	ground_provider?: BlockStateProvider,
	suspicious_provider?: BlockStateProvider,
	standard_provider?: BlockStateProvider,
	slab_provider?: BlockStateProvider,
	fluid_provider?: BlockStateProvider,
	/// The number of suspicious blocks to place per layer.
	suspicious_block_placements?: IntProvider<int @ 0..4>,
	suspicious_loot_table?: #[id="loot_table"] string
}





// STRUCTURE TYPES





type StructureRef = (
	#[id="worldgen/structure"] string |
	Structure
)

dispatch minecraft:resource[lithostitched:structure] to struct Structure {
	type: #[id="worldgen/structure_type"] string,
	...lithostitched:common_structure_options[[type]],
	...minecraft:structure_config[[type]],
}

dispatch lithostitched:common_structure_options["lithostitched:delegating"] to struct {}
dispatch lithostitched:common_structure_options[%none,%unknown] to struct {
	biomes: (
		[#[id="worldgen/biome"] string] |
		#[id(registry="worldgen/biome",tags=allowed)] string |
	),
	/// The step when the structure generates.
	step: DecorationStep,
	terrain_adaptation?: TerrainAdaptation,
	spawn_overrides: struct {
		[MobCategory]: SpawnOverride,
	},
}

dispatch minecraft:structure_config["lithostitched:delegating"] to struct DelegatingStructure {
	delegate: StructureRef,
	spawn_condition: PlacementCondition
}

dispatch minecraft:structure_config["lithostitched:jigsaw"] to struct JigsawStructure {
	start_pool: #[id="worldgen/template_pool"] string,
	size: (
		#[until="1.20.3"] IntProvider<int @ 0..7> |
		#[since="1.20.3"] IntProvider<int @ 0..128>
	),
	#[since="1.21"]
	fixed_rotation?: boolean,
	start_height: HeightProvider,
	start_jigsaw_name?: #[id] string,
	project_start_to_heightmap?: HeightmapType,
	max_distance_from_center: minecraft:jigsaw_max_distance_from_center[[terrain_adaptation]],
	use_expansion_hack: boolean,
	#[since="1.21"]
	pool_aliases?: [PoolAlias],
	#[since="1.21"]
	dimension_padding?: (
		int @ 0.. |
		struct DimensionPaddingConfig {
			bottom?: int @ 0..,
			top?: int @ 0..,
		}
	),
	#[since="1.21"]
	liquid_settings?: LiquidSettings,
}





// TEMPLATE POOL ELEMENTS





dispatch minecraft:template_pool_element["lithostitched:delegating"] to struct DelegatingElement {
	delegate: Element, 
	#[since="1.21"]
	name?: #[id] string,
	condition?: PlacementCondition,
	allowed_depth?: InclusiveRange<int @ 0..>,
	forced_count?: int @ 1..,
	max_count?: int @ 1..,
	#[since="1.21"]
	allow_bounding_box_collisions?: boolean,
	#[since="1.21"]
	other_pieces_can_intersect?: boolean,
	override_terrain_adaptation?: TerrainAdaptation
}

dispatch minecraft:template_pool_element["lithostitched:guaranteed"] to struct GuaranteedElement {
	delegate: Element, 
	min_depth?: int @ 0..,
	count: int @ 1..,
}

dispatch minecraft:template_pool_element["lithostitched:limited"] to struct LimitedElement {
	delegate: Element, 
	min_depth?: int @ 0..,
	limit: int @ 1..,
}





// STRUCTURE PROCESSORS





enum(string) RandomMode {
	PerBlock = "per_block",
	PerPiece = "per_piece"
}

type RandomSettings = (
	RandomMode |
	struct FullRandomSettings {
		mode?: RandomMode,
		name: #[id] string
	}
)

dispatch minecraft:template_processor["lithostitched:apply_random"] to struct ApplyRandomProcessor {
	mode: RandomSettings,
	processor_lists: (
		#[id(registry="worldgen/processor_list",tags="allowed")] string | 
		WeightedList<ProcessorListRef>
	),
}

dispatch minecraft:template_processor["lithostitched:block_swap"] to struct BlockSwapProcessor {
	blocks: struct BlockSwapMap {
		[#[id="block"] string]: #[id="block"] string,
	}
}

dispatch minecraft:template_processor["lithostitched:reference"] to struct ReferenceProcessor {
	processor_lists: (#[id(registry="worldgen/processor_list",tags="allowed")] string | [#[id="worldgen/processor_list"] string])
}

dispatch minecraft:template_processor["lithostitched:set_block"] to struct SetBlockProcessor {
	state_provider: BlockStateProvider,
	/// Whether to preserve the block state values from the previous input block. Defaults to true.
	preserve_state?: boolean,
	random_mode?: RandomMode,
	block_entity_modifier?: BlockEntityModifier
}

dispatch minecraft:template_processor["lithostitched:condition"] to struct ConditionProcessor {
	random_mode?: RandomSettings,
	if_true: (ProcessorCondition | [ProcessorCondition]),
	then: (Processor | [Processor]),
	else?: (Processor | [Processor]),
}





// STRUCTURE PROCESSORS





dispatch minecraft:resource[lithostitched:processor_condition] to struct ProcessorCondition {
	type: ProcessorConditionType,
	...lithostitched:processor_condition[[type]],
}

enum(string) ProcessorConditionType {
	AllOf = "lithostitched:all_of",
	AnyOf = "lithostitched:any_of",
	MatchingBlocks = "lithostitched:matching_blocks",
	Not = "lithostitched:not",
	Position = "lithostitched:position",
	RandomChance = "lithostitched:random_chance",
	True = "lithostitched:true",
}

dispatch lithostitched:processor_condition["lithostitched:all_of"] to struct AllOfCondition {
	conditions: [ProcessorCondition]
}

dispatch lithostitched:processor_condition["lithostitched:any_of"] to struct AnyOfCondition {
	conditions: [ProcessorCondition]
}

dispatch lithostitched:processor_condition["lithostitched:matching_blocks"] to struct MatchingBlocksCondition {
	blocks: (#[id(registry="block",tags="allowed")] string | [#[id="block"] string]),
	properties?: StatePredicate,
	/// The type of matching to do. input checks against the block in the structure template, location checks against the block in the world getting replaced. Defaults to input.
	match_type?: MatchType
}

enum(string) MatchType {
	Input = "input",
	Location = "location"
}

dispatch lithostitched:processor_condition["lithostitched:not"] to struct NotCondition {
	condition: ProcessorCondition
}

dispatch lithostitched:processor_condition["lithostitched:position"] to struct PositionCondition {
	predicate: PosRuleTest,
	/// The positional anchor to base the check on. Possible fields are structure_start for current/vanilla behavior and piece for piece-relative position checks. Defaults to structure start.
	anchor?: PosAnchor
}

enum(string) PosAnchor {
	StructureStart = "structure_start",
	Piece = "piece"
}

dispatch minecraft:processor_condition["lithostitched:random_chance"] to struct RandomChanceCondition {
	chance: float @ 0..1
}





// STRUCTURE PROCESSORS





dispatch minecraft:rule_block_entity_modifier["lithostitched:apply_all"] to struct ApplyAllModifier {
	modifiers: [BlockEntityModifier],
}

dispatch minecraft:rule_block_entity_modifier["lithostitched:apply_random"] to struct ApplyRandomModifier {
	modifiers: WeightedList<BlockEntityModifier>,
}





// SURFACE RULES





dispatch minecraft:resource["lithostitched:surface_rule"] to SurfaceRule

dispatch minecraft:surface_rule["lithostitched:bandlands"] to struct BandlandsRule {
	options: #[id="lithostitched:bandlands"] string,
}

dispatch minecraft:surface_rule["lithostitched:reference"] to struct ReferenceRule {
	rules: (#[id(registry="lithostitched:surface_rule",tags="allowed")] string | [#[id="lithostitched:surface_rule"] string]),
}

dispatch minecraft:surface_condition["lithostitched:all_of"] to struct AllOfMaterialCondition {
	conditions: [SurfaceCondition]
}

dispatch minecraft:surface_condition["lithostitched:any_of"] to struct AnyOfMaterialCondition {
	conditions: [SurfaceCondition]
}

dispatch minecraft:surface_condition["lithostitched:biome"] to struct BiomeMaterialCondition {
	biomes: (#[id(registry="worldgen/biome",tags="allowed")] string | [#[id="worldgen/biome"] string]),
}

dispatch minecraft:surface_condition["lithostitched:slope"] to struct SlopeMaterialCondition {
	height_difference?: InclusiveRange<int>
}
